Back-ported patch for upstream bug #55826.


diff -Naur mysql-5.0.77.orig/mysql-test/r/innodb_mysql.result mysql-5.0.77/mysql-test/r/innodb_mysql.result
--- mysql-5.0.77.orig/mysql-test/r/innodb_mysql.result	2009-01-29 17:38:16.000000000 -0500
+++ mysql-5.0.77/mysql-test/r/innodb_mysql.result	2010-10-22 17:17:53.989865453 -0400
@@ -1268,3 +1268,16 @@
 a
 DROP TABLE t1;
 End of 5.0 tests
+#
+# Bug#55826: create table .. select crashes with when KILL_BAD_DATA 
+#  is returned
+#
+CREATE TABLE t1(a INT) ENGINE=innodb;
+INSERT INTO t1 VALUES (0);
+SET SQL_MODE='STRICT_ALL_TABLES';
+CREATE TABLE t2 
+SELECT LEAST((SELECT '' FROM t1),NOW()) FROM `t1`;
+ERROR 22007: Truncated incorrect datetime value: ''
+DROP TABLE t1;
+SET SQL_MODE=DEFAULT;
+End of 5.1 tests
diff -Naur mysql-5.0.77.orig/mysql-test/t/innodb_mysql.test mysql-5.0.77/mysql-test/t/innodb_mysql.test
--- mysql-5.0.77.orig/mysql-test/t/innodb_mysql.test	2009-01-29 17:37:52.000000000 -0500
+++ mysql-5.0.77/mysql-test/t/innodb_mysql.test	2010-10-22 17:17:32.284914951 -0400
@@ -1026,3 +1026,19 @@
 DROP TABLE t1;
 
 --echo End of 5.0 tests
+
+--echo #
+--echo # Bug#55826: create table .. select crashes with when KILL_BAD_DATA 
+--echo #  is returned
+--echo #
+
+CREATE TABLE t1(a INT) ENGINE=innodb;
+INSERT INTO t1 VALUES (0);
+SET SQL_MODE='STRICT_ALL_TABLES';
+--error ER_TRUNCATED_WRONG_VALUE
+CREATE TABLE t2 
+  SELECT LEAST((SELECT '' FROM t1),NOW()) FROM `t1`;
+DROP TABLE t1;
+SET SQL_MODE=DEFAULT;
+
+--echo End of 5.1 tests
diff -Naur mysql-5.0.77.orig/sql/item_func.cc mysql-5.0.77/sql/item_func.cc
--- mysql-5.0.77.orig/sql/item_func.cc	2009-01-29 16:45:26.000000000 -0500
+++ mysql-5.0.77/sql/item_func.cc	2010-10-22 17:16:59.599004219 -0400
@@ -2269,7 +2269,7 @@
     stored to the value pointer, if latter is provided.
 
   RETURN
-   0	If one of arguments is NULL
+   0	If one of arguments is NULL or there was a execution error
    #	index of the least/greatest argument
 */
 
@@ -2284,6 +2284,14 @@
     Item **arg= args + i;
     bool is_null;
     longlong res= get_datetime_value(thd, &arg, 0, datetime_item, &is_null);
+
+    /* Check if we need to stop (because of error or KILL)  and stop the loop */
+    if (thd->net.report_error)
+    {
+      null_value= 1;
+      return 0;
+    }
+
     if ((null_value= args[i]->null_value))
       return 0;
     if (i == 0 || (res < min_max ? cmp_sign : -cmp_sign) > 0)
@@ -2312,6 +2320,12 @@
     if (null_value)
       return 0;
     str_res= args[min_max_idx]->val_str(str);
+    if (args[min_max_idx]->null_value)
+    {
+      // check if the call to val_str() above returns a NULL value
+      null_value= 1;
+      return NULL;
+    }
     str_res->set_charset(collation.collation);
     return str_res;
   }
